# 问题描述
有一个魔王总是使用自己的一种非常精炼而抽象的语言讲话，没有人能听得懂，但他的语言是可以逐步解释成人能听懂的语言，因为他的语言是由以下两种形式的规则由人的语言逐步抽象出来的：

1. $\alpha\rightarrow\beta_1\beta_2...\beta_m$
2. $(\theta\delta_1\delta_2...\delta_n)\rightarrow\theta\delta_n\theta\delta_{n-1}...\theta\delta_1\theta$

在两种形式中，从左到右均表示解释。

# 设计要求
用下述两条具体规则和上述规则形式`(2)`，试写一个魔王语言的解释系统，借助于栈和队列把他的话解释成人能听得懂的语言。

设大写字母表示魔王语言的词汇，小写字母表示人的语言词汇，希腊字母表示可以用大写字母或小写字母代换的变量。魔王语言可含人的词汇。

1. $B\rightarrow tAdA$
2. $A\rightarrow sae$

例如：`A(abcd)B`可解释为：`saeadacabatsaedsae`

# 第一次设计
第一次设计中，为了将问题简化，我们认为魔王语言中只会出现最多一层次的圆括号(即不会出现多重括号，类似`A(B[abcd]B)A`这样的话不会出现)，这样问题就简单了。

同时设计要求中，具体规则的第一条也可以结合第二条直接结合，代入变形为$B\rightarrow tsaedsae$，这样两条具体规则都可以直接使用单步替换操作实现。

这样理解后，翻译魔王语言就和翻译一般的外语区别不大了，现在我们设计整体算法来实现简单魔王语言的翻译。

## 输入魔王语言
为了限制程序的运行时间，我们认为输入的魔王语言应该是一行长度不超过`100`的非空合法字符串。

为了让输入最终变成长度不超过`100`的字符串，可以使用以下方法：

1. 创建一个长度为`101`的字符数组`ML`。
2. 通过`gets`函数将输入的一行字符串赋值给它。
3. 将`ML[100]`赋值为`'\0'`。

这样处理后，即使输入的字符串长度超过`100`也只能输出前`100`个字符。

## 合法性检验
为了保证进入程序处理的魔王语言是合法的，在正式翻译前，需要对输入的字符串进行合法性检验。

根据题目要求，输入的字符串应该满足以下要求：

1. 非空且只包含`A`、`B`、`a~z`、`()`。
2. 至多只有一层括号，并且括号应该是匹配的。

因此，合法性检验需要进行三次，一次用于检验是否非空，一次检验是否存在非法字符，一次检验括号是否只有一层且匹配。这两种检验算法都相当简单，本文档就不再赘述。

同时，如果检验得到字符串非法，根据检验出错的位置，可以返回参数表示字符串非法的原因。

## 翻译
魔王语言的翻译方法在这样的限制下和翻译外语的方法区别不大，具体步骤如下：

1. 若字符不在括号内并且属于人类语言词汇(即小写字母`a~z`)，就直接将其输出。
2. 若字符不在括号内并且属于魔王语言词汇(即大写字母`A~B`)，就按照题目中指定的具体规则输出。
3. 如果字符是左括号`(`，将`(`后的第一个非右括号`)`字符赋值给`t`，随后将`)`前的所有字符依次入栈`S`，接着输出`t`，再转步骤4。
4. 将栈顶元素出栈并按照步骤`1`、`2`输出，再输出`t`。
5. 重复执行步骤`4`，`S`为空时停止，然后跳过原字符串中的`)`，继续处理剩余的字符。
6. 返回指定参数表示翻译成功。

## 返回参数
为了让程序在每种情况下具有输出，因此每种情况下翻译结束时都返回一个参数，由主程序进行处理。下面列出各参数的含义，并给出相应额外操作：

| 返回参数 | 参数含义 | 额外操作 |
| :-: | :-: | :-: |
| 1 | 输入字符串翻译成功 | 输出信息“翻译成功” |
| 0 | 输入字符串为空串 | 输出错误“输入为空” |
| -1 | 输入字符串包含非法字符 | 输出第一个非法字符及其位置 |
| -2 | 输入字符串内括号层数过多 | 输出错误“输入包含多重括号” |
| -3 | 输入字符串中括号不匹配 | 输出第一个匹配失败的括号及其位置 |